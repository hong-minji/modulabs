<!DOCTYPE html>
<html lang="ko">
<head>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width, initial-scale=1" />
  <title>인터랙티브 Q&A 카드</title>
  <!-- Pretendard Variable -->
  <link rel="preconnect" href="https://cdn.jsdelivr.net" crossorigin>
  <link rel="stylesheet" href="https://cdn.jsdelivr.net/gh/orioncactus/pretendard/dist/web/pretendardvariable.css" />
  <style>
    :root {
      --bg: #0b0c10;
      --card: #111318;
      --text: #e7e9ee;
      --muted: #aeb3bd;
      --accent: #6ea8fe;
      --ring: rgba(110,168,254,.35);
      --shadow: 0 20px 50px rgba(0,0,0,.45);
      --radius: 22px;
      --gap: 16px;
    }
    @media (prefers-color-scheme: light) {
      :root {
        --bg: #f5f7fb;
        --card: #ffffff;
        --text: #101217;
        --muted: #606776;
        --accent: #3a7bfd;
        --ring: rgba(58,123,253,.25);
        --shadow: 0 20px 40px rgba(16,18,23,.1);
      }
    }

    * { box-sizing: border-box; }
    html, body { height: 100%; }
    body {
      margin: 0;
      background: radial-gradient(1200px 800px at 70% -10%, rgba(110,168,254,.16), transparent 40%), var(--bg);
      color: var(--text);
      font-family: 'Pretendard Variable', Pretendard, -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, 'Apple SD Gothic Neo', 'Noto Sans KR', 'Malgun Gothic', 'Apple Color Emoji', 'Segoe UI Emoji', sans-serif;
      -webkit-font-smoothing: antialiased;
      -moz-osx-font-smoothing: grayscale;
      display: grid;
      place-items: center;
    }

    .app {
      width: min(92vw, 860px);
      height: min(86vh, 720px);
      display: grid;
      grid-template-rows: 1fr auto;
      gap: var(--gap);
      position: relative;
    }

    .topbar {
      position: absolute;
      top: 10px;
      left: 50%;
      transform: translateX(-50%);
      font-size: 13px;
      color: var(--muted);
      letter-spacing: .01em;
      user-select: none;
      text-align: center;
      padding: 6px 10px;
      background: color-mix(in oklab, var(--card) 70%, transparent);
      backdrop-filter: blur(6px);
      border-radius: 999px;
      border: 1px solid rgba(127,127,127,.18);
    }

    .stage {
      position: relative;
      display: grid;
      place-items: center;
      perspective: 1600px;
      isolation: isolate;
    }

    .card {
      width: min(92vw, 720px);
      height: min(72vh, 560px);
      position: relative;
      transform-style: preserve-3d;
      border-radius: var(--radius);
      box-shadow: var(--shadow);
      transition: transform 700ms cubic-bezier(.2,.8,.2,1), box-shadow 400ms ease;
      background: linear-gradient(180deg, color-mix(in oklab, var(--card) 96%, #4b5563 4%), var(--card));
      border: 1px solid rgba(127,127,127,.22);
      cursor: pointer;
      outline: none;
    }
    .card:focus-visible { box-shadow: 0 0 0 6px var(--ring), var(--shadow); }
    .card.flipped { transform: rotateY(180deg); }

    .side {
      position: absolute;
      inset: 0;
      padding: clamp(18px, 3.2vw, 30px) clamp(20px, 3.6vw, 36px);
      border-radius: inherit;
      display: grid;
      grid-template-rows: auto 1fr;
      gap: clamp(8px, 1.6vw, 12px);
      backface-visibility: hidden;
    }

    .front .eyebrow { color: var(--muted); font-size: 13px; letter-spacing: .08em; text-transform: uppercase; }
    .front h2 { font-size: clamp(22px, 2.6vw, 32px); line-height: 1.35; margin: 4px 0 0; font-weight: 700; }

    .back { transform: rotateY(180deg); }
    .back .eyebrow { color: var(--muted); font-size: 13px; letter-spacing: .08em; text-transform: uppercase; }
    .back .answer { font-size: clamp(17px, 1.9vw, 20px); line-height: 1.75; white-space: pre-line; }

    .progress {
      display: flex; align-items: center; justify-content: center; gap: 8px; color: var(--muted);
      user-select: none; font-size: 14px;
    }

    .dots { display: flex; gap: 6px; }
    .dot { width: 6px; height: 6px; border-radius: 50%; background: color-mix(in oklab, var(--muted), transparent 50%); opacity: .5; transition: transform .3s ease, opacity .3s ease, background .3s ease; }
    .dot.active { opacity: 1; transform: scale(1.2); background: var(--accent); }

    .navBtn {
      position: absolute; top: 50%; translate: 0 -50%; z-index: 5;
      width: clamp(42px, 6.5vw, 60px); aspect-ratio: 1;
      display: grid; place-items: center; border-radius: 50%;
      background: color-mix(in oklab, var(--card) 72%, transparent);
      border: 1px solid rgba(127,127,127,.18);
      backdrop-filter: blur(6px);
      cursor: pointer; user-select: none;
      transition: transform .2s ease, background .2s ease;
    }
    .navBtn:hover { transform: translateY(-50%) scale(1.04); }
    .navBtn:active { transform: translateY(-50%) scale(.98); }
    .navBtn svg { width: 22px; height: 22px; fill: none; stroke: var(--text); stroke-width: 2; }
    .nav-left { left: -8px; }
    .nav-right { right: -8px; }

    .hint {
      position: absolute; bottom: 10px; left: 50%; transform: translateX(-50%);
      color: var(--muted); font-size: 12px; user-select: none; text-align: center;
      background: color-mix(in oklab, var(--card) 70%, transparent);
      border-radius: 999px; padding: 6px 10px; border: 1px solid rgba(127,127,127,.18);
    }

    @media (max-width: 640px) {
      .nav-left { left: -2px; }
      .nav-right { right: -2px; }
    }

    @media (prefers-reduced-motion: reduce) {
      .card { transition: none; }
      .dot { transition: none; }
      .navBtn { transition: none; }
    }
  </style>
</head>
<body>
  <div class="app" aria-live="polite">
    <div class="topbar">좌/우: 다음·이전 카드 · 상/하 & 클릭: 앞/뒤 뒤집기 · 스와이프 지원</div>

    <div class="stage">
      <button class="navBtn nav-left" aria-label="이전 카드" title="이전 카드(←)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M15 18l-6-6 6-6"/></svg>
      </button>

      <div class="card" id="card" role="button" tabindex="0" aria-pressed="false" aria-label="카드 뒤집기">
        <section class="side front" aria-hidden="false">
          <div class="eyebrow">Q.</div>
          <h2 id="question"></h2>
        </section>
        <section class="side back" aria-hidden="true">
          <div class="eyebrow">A.</div>
          <div class="answer" id="answer"></div>
        </section>
      </div>

      <button class="navBtn nav-right" aria-label="다음 카드" title="다음 카드(→)">
        <svg viewBox="0 0 24 24" aria-hidden="true"><path d="M9 6l6 6-6 6"/></svg>
      </button>

      <div class="hint">모바일: 좌/우 스와이프 이동 · 위/아래 스와이프 뒤집기</div>
    </div>

    <div class="progress" aria-hidden="true">
      <div class="dots" id="dots" aria-label="진행 표시"></div>
    </div>
  </div>

  <script>
    // 카드 데이터
    const cards = [
      {
        q: '야근이나 주말 근무가 많았을 때 어떻게 조율하나?',
        a: '처음에는 제 욕심 때문에 야근이나 주말 근무를 자주 했어요. 그런데 그게 습관이 되니까, 일을 할 수 있다는 기준이 야근까지 포함된 상태가 되더라고요. 사실 야근을 해야 할 수 있다면 할 수 있는 게 아니에요. 그래서 어쩔 수 없이 해야 할 때는 탄력 근무를 제안하거나 이후에 휴가를 꼭 요청했어요. 그렇지 않으면 “못 한다”고 말하는 게 맞다고 생각해요.'
      },
      {
        q: '일이 몰리거나 마감이 앞당겨졌을 때 우선순위는 어떻게 정하나?',
        a: '이럴 때는 꼭 무엇이 가장 중요한지 먼저 물어야 해요. 후속 일정에 어떤 영향을 미치는지 확인하고, 그에 맞게 우선순위를 정해야 해요. 욕심을 내서 퀄리티를 끝까지 끌어올리려 하면 결국 무너지니까, 효과적이고 깔끔한 수준에서 마무리하는 연습을 하는 게 좋아요. 완벽보다는 완성이 더 중요하다고 생각해요.'
      },
      {
        q: '회사가 워라밸을 지켜주지 않을 때 개인은 어떻게 지킬까?',
        a: '워라밸 없이 주어진 일을 다 해내면, 처음엔 인정받는 것 같아도 결국 더 많은 일을 떠맡게 돼요. 한 번 해내면 “저 사람은 이 정도도 할 수 있다”는 기준이 생기고, 상황은 점점 더 나빠져요. 성의를 다하는 건 필요하지만, 미래의 체력을 갈아 넣으면서까지 하면 안 돼요. 그래서 저는 항상 일정한 선을 지키려고 했어요. 적당히 하는 기준을 세우고, 필요하면 분명히 거절하는 게 결국 나 자신을 지키는 길이에요.'
      },
      {
        q: '업무가 감당 안 될 만큼 많을 때 거절하거나 조율한 경험은?',
        a: '처음부터 “여기까지는 할 수 있고, 이 이상은 어렵다”고 분명하게 말하는 게 중요해요. 만약 새로운 업무가 추가된다면 기존의 일을 줄여야 한다는 걸 함께 합의했어요. 안 된다고 말하는 것도 괜찮아요. 중요한 건 맡은 일을 깔끔하게 완성하는 거예요. 많이 하는 게 잘하는 게 아니라, 마무리를 제대로 하는 게 잘하는 거라고 생각해요.'
      },
      {
        q: '완벽을 추구하다가 힘들었던 적이 있나? 그럴 땐 어떻게 했나?',
        a: '저도 욕심나는 작업은 제 시간을 더 들여서 완벽하게 하려고 했던 적이 있어요. 그런데 그렇게 하다 보니 그게 습관이 되고, 결국은 저를 더 힘들게 하더라고요. 완벽이라는 건 사실 없어요. 잘하려고 하기보다는 끝내는 게 중요해요. 완성 그 자체가 발전이 된다고 믿어요.'
      },
      {
        q: '“열심히 하는 것”과 “효율적으로 하는 것”?',
        a: '많이, 오래 하는 열심히에 빠지면 결국 소모돼요. 진짜 열심히는 시간을 무조건 많이 쓰는 게 아니라, 생각을 잘하고 집중하는 데 있다고 생각해요. 효율적인 시스템을 만들어두면 반복적인 일에 시간을 덜 쓰고, 오히려 창의성에 더 집중할 수 있어요.'
      },
      {
        q: '기대만큼 결과가 안 나왔을 때 어떻게?',
        a: '결과가 기대만큼 나오지 않았을 때 꼭 처음부터 다시 할 필요는 없다고 생각해요. 다 엎고 새로 시작하는 게 답일 때도 있겠지만, 대부분은 지금 있는 상태에서 부족한 부분만 조금 고치고 마무리하는 게 훨씬 나아요. 완벽하지 않아도 끝내는 경험 자체가 소중하고, 그 안에서 배운 점이 다음에 더 나은 결과를 만드는 힘이 된다고 믿어요.'
      },
      {
        q: '초년생 시절로 돌아간다면, 어떤 태도로 일과 삶을 대했을까?',
        a: '초년생 시절로 돌아간다면 못해도 괜찮다고, 실수해도 괜찮다고 말해주고 싶어요. 민폐를 끼쳐도, 잘하지 않아도 전혀 문제없다고 생각해요.'
      }
    ];

    const cardEl = document.getElementById('card');
    const qEl = document.getElementById('question');
    const aEl = document.getElementById('answer');
    const dotsEl = document.getElementById('dots');
    const prevBtn = document.querySelector('.nav-left');
    const nextBtn = document.querySelector('.nav-right');

    let index = 0;
    let flipped = false;

    // Initialize dots
    function renderDots() {
      dotsEl.innerHTML = cards.map((_, i) => `<span class="dot${i===index?' active':''}"></span>`).join('');
    }

    function renderCard() {
      const { q, a } = cards[index];
      qEl.textContent = q;
      aEl.textContent = a;
      // reset to question side when (re)visiting a card
      flipped = false;
      cardEl.classList.remove('flipped');
      cardEl.setAttribute('aria-pressed', 'false');
      cardEl.querySelector('.front').setAttribute('aria-hidden', 'false');
      cardEl.querySelector('.back').setAttribute('aria-hidden', 'true');
      renderDots();
    }

    function flipCard() {
      flipped = !flipped;
      cardEl.classList.toggle('flipped', flipped);
      cardEl.setAttribute('aria-pressed', String(flipped));
      cardEl.querySelector('.front').setAttribute('aria-hidden', String(flipped));
      cardEl.querySelector('.back').setAttribute('aria-hidden', String(!flipped));
    }

    function next() { index = (index + 1) % cards.length; renderCard(); }
    function prev() { index = (index - 1 + cards.length) % cards.length; renderCard(); }

    // Event: click/tap to flip
    cardEl.addEventListener('click', (e) => {
      // Ignore if clicking buttons overlaying? (no buttons on card)
      flipCard();
    });

    // Keyboard controls
    document.addEventListener('keydown', (e) => {
      if (e.key === 'ArrowRight') { e.preventDefault(); next(); }
      else if (e.key === 'ArrowLeft') { e.preventDefault(); prev(); }
      else if (e.key === 'ArrowUp' || e.key === 'ArrowDown' || e.key === 'Enter' || e.key === ' ') {
        e.preventDefault(); flipCard();
      }
    });

    prevBtn.addEventListener('click', prev);
    nextBtn.addEventListener('click', next);

    // Touch gestures (swipe) — horizontal for navigation, vertical for flip
    let touchStartX = 0, touchStartY = 0, touchTime = 0;
    const SWIPE_THRESHOLD = 40; // px
    const SWIPE_TIME = 700; // ms

    function onTouchStart(e) {
      const t = e.changedTouches[0];
      touchStartX = t.clientX;
      touchStartY = t.clientY;
      touchTime = Date.now();
    }

    function onTouchEnd(e) {
      const t = e.changedTouches[0];
      const dx = t.clientX - touchStartX;
      const dy = t.clientY - touchStartY;
      const dt = Date.now() - touchTime;

      if (dt > SWIPE_TIME) return; // too slow

      if (Math.abs(dx) > Math.abs(dy) && Math.abs(dx) > SWIPE_THRESHOLD) {
        // horizontal swipe
        if (dx < 0) next(); else prev();
      } else if (Math.abs(dy) > SWIPE_THRESHOLD) {
        // vertical swipe flips
        flipCard();
      }
    }

    // Use passive listeners for performance
    cardEl.addEventListener('touchstart', onTouchStart, { passive: true });
    cardEl.addEventListener('touchend', onTouchEnd, { passive: true });

    // Prime
    renderDots();
    renderCard();

    // Keep focus on card for accessibility hints
    window.addEventListener('load', () => cardEl.focus({ preventScroll: true }));
  </script>
</body>
</html>
